# -*- coding: utf-8 -*-
"""AIBIbackend.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SDQgC9Su4NGl8nlA6ItQ4gNMsS-HD7dk
"""

!pip install openai

import openai
import pandas as pd
from matplotlib import pyplot as plt
from dateutil.parser import parse
from statistics import stdev

data = pd.read_excel("FeatureList.xlsx")
df = data.dropna(how="all", axis=1) #Remove All Empty Columns

def is_likely_date(string): #Determines If A String Is A Date
    try:
        parse(string)
        return True
    except ValueError:
        return False

def is_likely_num(string):
    try:
        float(string)
        return True
    except ValueError:
        return False

intermediateDict = {}
numericalType = []
categoricalType = []

for col in df.columns: #Some Cols contain values of more than one data type. Deal with this by chooing most frequent data type and removing the rest
  categoriesDict = {}
  for value in df[col]:
    if str(type(value)) == "<class 'pandas._libs.tslibs.nattype.NaTType'>" or pd.isna(value): #NaN is a float type by default
      break
    elif str(type(value)) == "<class 'pandas._libs.tslibs.timestamps.Timestamp'>":
      if "<class 'pandas._libs.tslibs.timestamps.Timestamp'>" in categoriesDict.keys():
        categoriesDict["<class 'pandas._libs.tslibs.timestamps.Timestamp'>"] += 1
      else:
        categoriesDict["<class 'pandas._libs.tslibs.timestamps.Timestamp'>"] = 1
    elif is_likely_num(value):
      currentType = type(3.6)
    else:
      currentType = type(value)
    if str(currentType) in categoriesDict.keys():
      categoriesDict[str(currentType)] += 1
    else:
      categoriesDict[str(currentType)] = 1
  sortedDict =  sorted(categoriesDict.items(), key=lambda x:x[1], reverse=True)
  if len(sortedDict) > 0:
    theType = sortedDict[0][0]
    listOfValues = []
    for value in df[col]:
      if str(type(value)) == str(theType):
          listOfValues.append(value)
      else:
        listOfValues.append("REMOVE")
    intermediateDict[col] = listOfValues
    if theType == str(type(3.6)):
      #print("Going to Numerical")
      numericalType.append(col)
    else:
      #print("Going to Categorical")
      categoricalType.append(col)



standardDevDict = {}
for col in numericalType:
  listToUse = []
  for i in range(len(intermediateDict[col])):
    if isinstance(intermediateDict[col][i], (float)) and str(intermediateDict[col][i]) != "nan":
      listToUse.append(intermediateDict[col][i])
  if len(listToUse) > 1:
    standardDevDict[col] = stdev(listToUse)
  else:
    standardDevDict[col] = 0

sortedSEDict =  sorted(standardDevDict.items(), key=lambda x:x[1], reverse=True)

openai.api_key = input("OPEN AI KEY: ")
messages = [ {"role": "system", "content":
			"You are a intelligent assistant."} ]

message = "Here is a list of the names of numerical metrics: " + str(numericalType) + ". Here is a list of the names of categorical metrics: " + str(categoricalType) +  ". Based on this, provide recommendations on the 3 - 4 most insightful graphs to generalize. Make sure to include which variable is the independent and which is dependent as well as the type of graph that should be generated"
if message:
	messages.append(
		{"role": "user", "content": message},
	)
	chat = openai.ChatCompletion.create(
		model="gpt-3.5-turbo", messages=messages
	)
reply = chat.choices[0].message.content
messages.append({"role": "assistant", "content": reply})


def Convert(string):
  actual_list = []
  for colName in categoricalType:
    if colName in string:
      actual_list.append(colName)
  return actual_list


print(reply)

varsList = Convert(reply)
print(varsList)

for generatedTuple in varsList:
  x_axis_var = generatedTuple[0]
  y_axis_var = generatedTuple[1]
  if x_axis_var in intermediateDict.keys():
      getTheXList = intermediateDict[x_axis_var]
      getTheYList = intermediateDict[y_axis_var]
      finalListX = []
      finalListY = []
      num_points = min(20, len(getTheXList))  # Maximum of 20 points or the total number of available points
      for i in range(num_points):
          if getTheXList[i] != "REMOVE" and getTheYList[i] != "REMOVE":
              if isinstance(getTheXList[i], (str)):
                  toAppend = getTheXList[i][0:10] + "..."
              else:
                  toAppend = str(getTheXList[i])
              finalListX.append(toAppend)
              finalListY.append(getTheYList[i])
      if len(set(finalListX)) >= 1:
          if is_likely_date(finalListX[1]):
            sorted_indices = sorted(range(len(finalListX)), key=lambda i: parse(finalListX[i]))
            sorted_finalListX = [finalListX[i] for i in sorted_indices]
            sorted_finalListY = [finalListY[i] for i in sorted_indices]
            plt.plot(sorted_finalListX, sorted_finalListY)
          else:
            plt.bar(finalListX, finalListY)
            plt.xticks(rotation=90)
            plt.xlabel(x_axis_var)
            plt.ylabel(y_axis_var)
            plt.show()